<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<style>
.slidecontainer {
    width: 100%; /* Width of the outside container */
}

/* The slider itself */
.slider {
    -webkit-appearance: none;  /* Override default CSS styles */
    appearance: none;
    width: 100%; /* Full-width */
    height: 25px; /* Specified height */
    background: #d3d3d3; /* Grey background */
    outline: none; /* Remove outline */
    opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
    -webkit-transition: .2s; /* 0.2 seconds transition on hover */
    transition: opacity .2s;
}

/* Mouse-over effects */
.slider:hover {
    opacity: 1; /* Fully shown on mouse-over */
}

/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
.slider::-webkit-slider-thumb {
    -webkit-appearance: none; /* Override default look */
    appearance: none;
    width: 25px; /* Set a specific slider handle width */
    height: 25px; /* Slider handle height */
    background: #4CAF50; /* Green background */
    cursor: pointer; /* Cursor on hover */
}

.slider::-moz-range-thumb {
    width: 25px; /* Set a specific slider handle width */
    height: 25px; /* Slider handle height */
    background: #4CAF50; /* Green background */
    cursor: pointer; /* Cursor on hover */
}
</style>

<script>

function p3( x, y, z ) { return { x:x, y:y, z:z }; }
function p2( x, y ) { return { x:x, y:y, z:0 }; }
function origin() { return p3(0,0,0); }
function xaxis() { return p3(1,0,0); }
function yaxis() { return p3(0,1,0); }
function zaxis() { return p3(0,0,1); }
function add( a, b ) { return p3( a.x + b.x, a.y + b.y, a.z + b.z ); }
function sub( a, b ) { return p3( a.x - b.x, a.y - b.y, a.z - b.z ); }
function mul( a, f ) { return p3( a.x * f, a.y * f, a.z * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
function len2( a ) { return dot( a, a ); }
function len( a ) { return Math.sqrt( len2( a ) ); }
function dist( a, b ) { return len( sub( a, b ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; a.z = b.z; }
function normalize( a ) { return mul( a, 1 / len( a ) ); }
function cross( a, b ) { return p3( a.y * b.z - a.z * b.y, a.z*b.x - a.x * b.z, a.x * b.y - a.y * b.x ); }
function mid( a, b ) { return mul( add( a, b ), 0.5 ); }
function angle( p1, p2, p3 ) { var a = dist(p2,p3); var b = dist(p1,p2); var c = dist(p1,p3); return Math.acos( ( c*c - a*a - b*b ) / ( -2*a*b ) ); }
function rot2d( v, theta ) { var s = Math.sin(theta); var c = Math.cos(theta); return p2( v.x*c - v.y*s, v.x*s + v.y*c ); }
function deg2rad(deg) { return deg * Math.PI / 180; }

function clear() {
    verts = [];
    verts2d = [];
    shadow_verts2d = [];
    edges = [];
    faces = [];
    angles = [];
}

function getMousePos( evt ) {
    var rect = evt.target.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( evt );
    var canvas = evt.target;
    view_height = 1.3 * ( canvas.height / 2.0 - pos.y ) / canvas.height;
    repositionCamera();
}

function onMouseDown( evt ) {
    var pos = getMousePos( evt );
    isSpinning = !isSpinning;
}

function repositionCamera() {
    var look_at = p3(0,0,0);
    var d = 40;
    var vd = d * view_height;
    var hd = Math.sqrt( d*d - vd*vd );
    camera.p = p3( hd*Math.cos(camera_theta), hd*Math.sin(camera_theta), vd  );
    camera.z = normalize( sub( look_at, camera.p ) );
    var up = p3(0,0,1);
    camera.x = normalize( cross( camera.z, up ) );
    camera.y = normalize( cross( camera.x, camera.z ) );
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

function add_vert( p ) {
    verts.push( p );
    return verts.length-1;
}

function make_edge(i,j) {
    edges.push( [i,j] );
}

function make_face3(i,j,k) {
    faces.push( [i,j,k] );
    make_edge(i,j);
    make_edge(j,k);
    make_edge(k,i);
}

function make_face4(i,j,k,m) {
    faces.push( [i,j,k,m] );
    make_edge(i,j);
    make_edge(j,k);
    make_edge(k,m);
    make_edge(m,i);
}

function make_face5(i,j,k,m,n) {
    faces.push( [i,j,k,m,n] );
    make_edge(i,j);
    make_edge(j,k);
    make_edge(k,m);
    make_edge(m,n);
    make_edge(n,i);
}

function make_zome() {

    clear();

    // TODO: if K is vertical coord of 4th point, add new parameter to control its horizontal position

    world_scale = scale * 0.001;

    var M = N-1; // number of rows of faces
    var cos_theta = Math.cos(deg2rad(theta));
    var sin_theta = Math.sin(deg2rad(theta));
    var zome_height = H * world_scale;
    var total_polar_height = zome_height / D;
    var tip_Z = zome_height / 2;
    var kite_ratio_sum = (K==1) ? (M+1) : (1-Math.pow(K,M+1)) / (1-K);
    var top_edge_length =  total_polar_height / ( kite_ratio_sum * cos_theta );
    ground_level = tip_Z - zome_height;

    // add the top vert
    add_vert( p3( 0, 0, tip_Z ) );

    // add the top ring of vertices
    var ring1_radius = top_edge_length * sin_theta;
    var ring1_height = top_edge_length * cos_theta;
    for(var i=0; i<N; i++) {
        var a = i*2*Math.PI / N;
        var p = p3( ring1_radius * Math.sin(a), ring1_radius * Math.cos(a), tip_Z-ring1_height );
        add_vert( p ); // we assume that this is above ground level
    }

    // add the faces
    var hit_ground = false;
    var triangles = [];
    for(var r=1;r<=M && !hit_ground;r++) {
        for(var i=0;i<N;i++) {
            var ia = (r-1)*N+1+i;
            var ib = Math.max(0,(r-2)*N+1+(i+1)%N);
            var ic = (r-1)*N+1+(i+1)%N;
            var a = verts[ ia ];
            var b = verts[ ib ];
            var c = verts[ ic ];
            var d = add(b,mul(sub(mid(a,c),b),1+K)); // make a kite (rhombus if K=1)
            if( d.z >= ground_level ) {
                var id = add_vert( d );
                make_face4( ia, ib, ic, id );
                if(d.z === ground_level) {
                    // deal with case where this ring is exactly on the ground
                    hit_ground = true;
                    triangles.push(id);
                    triangles.push(id);
                    triangles.push(ic);
                }
            }
            else {
                var u = (ground_level - a.z ) / (d.z - a.z);
                var e = add(a,mul(sub(d,a),u));
                var f = add(c,mul(sub(d,c),u));
                var ie = add_vert( e );
                var i_f = add_vert( f );
                make_face5( ia, ib, ic, i_f, ie );
                hit_ground = true;
                triangles.push(ie);
                triangles.push(i_f);
                triangles.push(ic);
            }
        }
    }

    // add the bottom row of triangles as needed
    if(triangles.length>0) {
        for(var i=0;i<triangles.length;i+=3) {
            var ia = triangles[(i+1)%triangles.length];
            var ib = triangles[(i+2)%triangles.length];
            var ic = triangles[(i+3)%triangles.length];
            if( ia < verts.length && ib < verts.length && ic < verts.length ) {
                make_face3( ia, ib, ic );
            }
        }
    }

    var widest_diameter = 0;
    for(var iVert = 0; iVert < verts.length; iVert++) {
        var v = verts[ iVert ];
        var diameter = dist( v, p3( 0, 0, v.z ) ) / world_scale;
        if( diameter > widest_diameter ) {
            widest_diameter = diameter;
        }
    }
    var base_diameter = dist( verts[verts.length-1], p3(0,0,ground_level) ) / world_scale;
    document.getElementById("base_diameter_label").innerHTML = "Base diameter: "+base_diameter.toFixed(0)+" mm";
    document.getElementById("widest_diameter_label").innerHTML = "Widest diameter: "+widest_diameter.toFixed(0)+" mm";
}

function init() {

    var canvas = document.getElementById('canvas');

    camera_theta = Math.PI / 2;
    view_height = 0.5;
    camera = { p:p3(0,3,-6),
               x:p3(1,0,0),
               y:p3(0,1,0),
               z:p3(0,0,1),
               f:canvas.height,
               pp:p2(canvas.width/2,canvas.height/2)
             };
    repositionCamera();

    var scale_slider = document.getElementById("scale_slider");
    scale_slider.updatefromvalue = function() {
        scale = parseFloat(this.value);
        document.getElementById("scale_label").innerHTML = "Render scale: "+scale;
    }
    scale_slider.oninput = function() {
        this.updatefromvalue();
        make_zome();
    }
    scale_slider.updatefromvalue();

    var H_slider = document.getElementById("height_slider");
    H_slider.updatefromvalue = function() {
        H = parseFloat(this.value);
        document.getElementById("height_label").innerHTML = "Height: "+H+" mm";
    }
    H_slider.oninput = function() {
        this.updatefromvalue();
        make_zome();
    }
    H_slider.updatefromvalue();

    var N_slider = document.getElementById("N_slider");
    N_slider.updatefromvalue = function() {
        N = parseFloat(this.value);
        document.getElementById("N_label").innerHTML = "N: "+N;
    }
    N_slider.oninput = function() {
        this.updatefromvalue();
        make_zome();
    }
    N_slider.updatefromvalue();

    var theta_slider = document.getElementById("theta_slider");
    theta_slider.updatefromvalue = function() {
        theta = parseFloat(this.value);
        document.getElementById("theta_label").innerHTML = "Angle: "+theta;
    }
    theta_slider.oninput = function() {
        this.updatefromvalue();
        make_zome();
    }
    theta_slider.updatefromvalue();

    var D_slider = document.getElementById("D_slider");
    D_slider.updatefromvalue = function() {
        D = parseFloat(this.value);
        document.getElementById("D_label").innerHTML = "Cut proportion: "+D;
    }
    D_slider.oninput = function() {
        this.updatefromvalue();
        make_zome();
    }
    D_slider.updatefromvalue();

    var kite_slider = document.getElementById("kite_slider");
    kite_slider.updatefromvalue = function() {
        K = parseFloat(this.value);
        document.getElementById("kite_label").innerHTML = "Kite ratio: "+K;
    }
    kite_slider.oninput = function() {
        this.updatefromvalue();
        make_zome();
    }
    kite_slider.updatefromvalue();

    make_zome();

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onMouseMove, false );
    canvas.addEventListener( 'touchstart', onMouseDown, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );

    isSpinning = true;
    animate();
}

function camera_projection( p, camera ) {
    var ray = sub( p, camera.p ); // the ray from camera center to point
    var cp = p3( dot( camera.x, ray ), dot( camera.y, ray ), dot( camera.z, ray ) ); // into camera space
    return p3( cp.x * camera.f / cp.z + camera.pp.x,
               canvas.height - ( cp.y * camera.f / cp.z + camera.pp.y ),
               cp.z );
}

function point( ctx, p ) {
    ctx.beginPath();
    ctx.arc( p.x, p.y, 2, 0, 2.0 * Math.PI );
    ctx.fill();
}

function redraw() {
    drawMesh();
    drawNet();
}

function drawMesh() {

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');

    // project the mesh onto the screen
    for( var iVert = 0; iVert < verts.length; ++iVert ) {
        verts2d[ iVert ] = camera_projection( verts[ iVert ], camera );
    }

    // also project the verts onto the ground
    var sun = p3( -50, 50, 70 );
    var shadow_verts = [];
    for( var iVert = 0; iVert < verts.length; ++iVert ) {
        var vert = verts[iVert];
        var u = (ground_level - sun.z) / (vert.z - sun.z);
        var p = add( sun, mul( sub( vert, sun ), u ) );
        shadow_verts2d[ iVert ] = camera_projection( p, camera );
    }

    ctx.strokeStyle = "rgb(200,200,200)";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // draw the faces
    ctx.fillStyle = "rgba(200,210,255,0.2)";
    for( var iFace = 0; iFace < faces.length; ++iFace ) {
        var iVert = faces[iFace][0];
        if( iVert < verts2d.length ) {
            var a = verts2d[ iVert ];
            ctx.beginPath();
            ctx.moveTo( a.x, a.y );
            for( var i = 1; i < faces[iFace].length; ++i ) {
                var iVert = faces[iFace][i];
                if( iVert < verts2d.length ) {
                    a = verts2d[ iVert ];
                    ctx.lineTo( a.x, a.y );
                }
                else {
                    console.log('Invalid vert index:',iVert,'in face',iFace);
                }
            }
            ctx.fill();
        }
    }

    // draw the shadow edges
    ctx.strokeStyle = "rgb(240,240,240)";
    ctx.beginPath();
    for( var i = 0; i < edges.length; ++i ) {
        var iVertA = edges[i][0];
        var iVertB = edges[i][1];
        if( iVertA < shadow_verts2d.length && iVertB < shadow_verts2d.length ) {
            var a = shadow_verts2d[ iVertA ];
            var b = shadow_verts2d[ iVertB ];
            ctx.moveTo( a.x, a.y );
            ctx.lineTo( b.x, b.y );
        }
    }
    ctx.stroke();

    // draw the edges
    ctx.strokeStyle = "rgb(200,200,200)";
    ctx.beginPath();
    for( var i = 0; i < edges.length; ++i ) {
        var iVertA = edges[i][0];
        var iVertB = edges[i][1];
        var iVertB = edges[i][1];
        if( iVertA < verts2d.length && iVertB < verts2d.length ) {
            var a = verts2d[ iVertA ];
            var b = verts2d[ iVertB ];
            ctx.moveTo( a.x, a.y );
            ctx.lineTo( b.x, b.y );
        }
    }
    ctx.stroke();

    // draw the verts
    ctx.fillStyle = "rgb(0,0,0)";
    for( var i = 0; i < verts2d.length; ++i ) {
        point( ctx, verts2d[i], "" );
    }
}

function drawNet() {

    var canvas = document.getElementById('canvas2');
    var ctx = canvas.getContext('2d');

    ctx.strokeStyle = "rgb(200,200,200)";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "rgba(200,210,255,0.2)";
    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.beginPath();

    // first triangle:
    var edge1 = 100;
    var tri_height = 120;
    var a = p2( 100, canvas.height-100 );
    var b = p2( a.x+edge1, a.y );
    var c = p2( a.x+edge1/2, a.y - tri_height );
    ctx.moveTo(a.x,a.y);
    ctx.lineTo(b.x,b.y);
    ctx.lineTo(c.x,c.y);
    ctx.lineTo(a.x,a.y);

    ctx.fill();
    ctx.stroke();
}

function animate() {
    if( isSpinning ) {
        // rotate round
        camera_theta += 0.004;
        repositionCamera();
    }
    redraw();
    requestAnimationFrame( animate );
}

function download(filename, type, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:'+type+';charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);
  element.style.display = 'none';
  document.body.appendChild(element);
  element.click();
  document.body.removeChild(element);
}

function downloadOBJ() {
    var obj = "# OBJ produced by https://timhutton.github.io/zomes/\n";
    for( var iVert = 0; iVert < verts.length; iVert++ ) {
        var v = mul( add( verts[ iVert ], p3( 0, 0, -ground_level ) ), 1 / world_scale );
        obj += "v " + v.x + " " + v.y + " " + v.z + "\n";
    }
    for( var iFace = 0; iFace < faces.length; ++iFace ) {
        obj += "f";
        for( var iFaceVert = 0; iFaceVert < faces[iFace].length; iFaceVert++ ) {
            var iVert = faces[iFace][iFaceVert];
            obj += " " + (iVert+1); // (OBJ format uses 1-based indices)
        }
        obj += "\n";
    }
    download("zome.obj", "application/object", obj);
}

window.onload = init;

</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<table border="0">
  <tr>
    <td>
      <canvas id="canvas" width="800" height="600">(Canvas drawing not supported by your browser.)</canvas>
      <br>
      <canvas id="canvas2" width="800" height="600">(Canvas drawing not supported by your browser.)</canvas>
    </td>
    <td width="300px" valign="top">
      <p id="scale_label">Render scale:</p>
      <div class="slidecontainer"><input type="range" min="0.5" max="200" value="10" step="0.1" class="slider" id="scale_slider"></div>
      <p id="height_label">Height:</p>
      <div class="slidecontainer"><input type="range" min="100" max="10000" value="2000" step="10" class="slider" id="height_slider"></div>
      <p id="N_label">N:</p>
      <div class="slidecontainer"><input type="range" min="3" max="25" value="14" step="1" class="slider" id="N_slider"></div>
      <p id="theta_label">theta:</p>
      <div class="slidecontainer"><input type="range" min="15" max="80" value="50" step="1" class="slider" id="theta_slider"></div>
      <p id="D_label">Cut proportion:</p>
      <div class="slidecontainer"><input type="range" min="0.1" max="1" value="0.6" step="0.01" class="slider" id="D_slider"></div>
      <p id="kite_label">Kite ratio:</p>
      <div class="slidecontainer"><input type="range" min="0.8" max="1.2" value="1" step="0.001" class="slider" id="kite_slider"></div>
      <p id="base_diameter_label">Base diameter:</p>
      <p id="widest_diameter_label">Widest diameter:</p>
      <button onclick="downloadOBJ();">Download 3D scene as OBJ</button>
    </td>
  </tr>
</table>

<p>
Source code: <a href="https://github.com/timhutton/zomes">https://github.com/timhutton/zomes</a>
</p>

</body>

</html>
